// apps/backend/src/types/env.ts
/**
 * Cloudflare Worker Environment Bindings
 *
 * Base types are generated by `wrangler types` in worker-configuration.d.ts
 * The Cloudflare namespace is globally available when worker-configuration.d.ts
 * is included in tsconfig.json
 *
 * This file extends those types with additional custom properties
 */

import type { PdfProcessor } from "../processing/pdf-processor-container"
import type { PlanProcessingParams } from "../workflows/plan-processing"

export interface Env extends Cloudflare.Env {
  // Environment variables (set via wrangler.toml or secrets)
  SESSION_SECRET?: string
  GOOGLE_CLIENT_ID?: string
  GOOGLE_CLIENT_SECRET?: string
  GITHUB_CLIENT_ID?: string
  GITHUB_CLIENT_SECRET?: string

  // OpenRouter API for LLM-based callout detection and daily summaries
  OPENROUTER_API_KEY?: string
  OPENROUTER_MODEL?: string

  // OpenAI API for Whisper audio transcription
  OPENAI_API_KEY?: string

  LIVESTORE_CLIENT_DO: DurableObjectNamespace

  // R2 Storage
  R2_BUCKET: R2Bucket

  // Cloudflare Container for VIPS/Python processing
  PDF_PROCESSOR: DurableObjectNamespace<PdfProcessor>

  // Cloudflare Workflow for PDF processing pipeline
  PLAN_PROCESSING_WORKFLOW: Workflow<PlanProcessingParams>

  // Dev-only: bypass workerd container.fetch() by routing to local Flask server
  LOCAL_CONTAINER_URL?: string
}

/**
 * Durable Object Context
 * Extended with user information from auth validation
 */
export interface SyncContext {
  // Original payload from client
  payload: {
    authToken: string
    [key: string]: any
  }

  // User information added by validateSyncPayload
  userId?: string
  userEmail?: string

  // Request context
  request: Request
  env: Env
}

/**
 * Better Auth Session
 */
export interface Session {
  id: string
  token: string
  userId: string
  expiresAt: number
  ipAddress?: string
  userAgent?: string
  user: {
    id: string
    email: string
    name?: string
    image?: string
    emailVerified: boolean
  }
}

/**
 * LiveStore Event with metadata
 */
export interface EventWithMetadata<T = any> {
  id: string
  type: string
  data: T
  timestamp: number
  userId?: string
  storeId: string
}

/**
 * Push message from client
 */
export interface PushMessage {
  type: "push"
  batch: EventWithMetadata[]
  authToken: string
}

/**
 * Pull message from client
 */
export interface PullMessage {
  type: "pull"
  since?: string // Last event ID
  authToken: string
}

/**
 * Authorization check result
 */
export interface AuthorizationResult {
  allowed: boolean
  reason?: string
  userId: string
}
